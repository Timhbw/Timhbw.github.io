<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="自学iOS开发进阶博客，分享高质量的iOS开发技术。">
<meta property="og:type" content="website">
<meta property="og:title" content="Tim博客">
<meta property="og:url" content="http://timhbw.github.io/page/7/index.html">
<meta property="og:site_name" content="Tim博客">
<meta property="og:description" content="自学iOS开发进阶博客，分享高质量的iOS开发技术。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tim博客">
<meta name="twitter:description" content="自学iOS开发进阶博客，分享高质量的iOS开发技术。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://timhbw.github.io/page/7/"/>





  <title> Tim博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tim博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不忘初心，方得始终</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://timhbw.github.io/2016/03/24/34/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Timhbw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tim博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/24/34/" itemprop="url">
                  自用图片压缩工具推荐（优化博客加载速度）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-23T18:22:30Z">
                2016-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/建站/" itemprop="url" rel="index">
                    <span itemprop="name">建站</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前wordpress写博客时文章里面的图片都是上传到服务器中，以前以为这样省事，都是原图上传，发现到后面弊端就出来啦。图片越来越多，服务器容量不够用不说，前端加载速度慢，影响读者阅读，导致读者流失。</p>
<p>毕竟那时候刚开始接触博客，随着后来知识面拓展，阅读量增加，发现这种做法效率太低。说下我现在的做法：</p>
<ol>
<li>图片本地压缩</li>
<li>上传到空间上。例如七牛，腾讯云，利用CDN加速。<br>下面详细讲解下：</li>
</ol>
<h3 id="1-图片本地压缩"><a href="#1-图片本地压缩" class="headerlink" title="1.图片本地压缩"></a>1.图片本地压缩</h3><p>有时候博客或者网页里面需要插入图片，毕竟图文并茂对于读者来说更加有吸引力，更容易理解。图片利用压缩软件压缩，一般可以压缩50%以上，大大节省服务器空间和网页加载速度。<br>这里提供我用的软件，这个软件好处就是图片拖进去，不用处理，原图片直接覆盖，其他的软件一般是输出到另一个文件夹，文件名也会改变，不方便。这个软件免费版一次只能处理10张图片，等于你要处理10张以后关闭，再打开，付费版没有限制。<br>PP鸭下载链接：[file]</p>
<h3 id="图片上传空间加速"><a href="#图片上传空间加速" class="headerlink" title="图片上传空间加速"></a>图片上传空间加速</h3><p>用得最多的恐怕就是七牛吧。大概的工作原理我通俗的解释下：</p>
<ol>
<li>首先是图片存储在你自己服务器上：读者访问你的文章，直接从本地服务器加载图片。（用的是自己的流量，自己的服务器处理，没有额外加速buff）<br>点击测试：<a href="http://www.huangbowei.com/favicon.ico" target="_blank" rel="external">我存在自己服务器上的图片</a></li>
<li>如果存储在七牛等上：读者访问你的文章，直接从七牛服务器加载图片。（用的是七牛的流量，七牛的服务器，根据服务商不同，可能会提供加速服务，减轻服务器压力，提高页面加载速度，有额外buff）<br>点击测试：<a href="http://huangboweicom-10023220.file.myqcloud.com/images/favicon.ico" target="_blank" rel="external">我存在腾讯cos上的图片</a></li>
</ol>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我说下感想：</p>
<ol>
<li>毕竟自己用的是腾讯云的主机，发现用腾讯的存储空间还是挺方便的。七牛作为使用人数和接受度比较高的厂商，在前几年用的人多（可能现在还是比较多），因为免费还不需要备案就可以使用，对于服务器流量，性能不够的用户还是灰常不错的，一开始我也尝试用过七牛，但是不太方便，速度不太理想，图片还没有我放在本地加载快，而且想要使用CDN加速好像得充值10元验证你的账户。腾讯云就不一样，服务和价格都在那里，而且速度好，结合自己用的也是腾讯云的主机，事半功倍，图片也提供CDN加速。</li>
<li>我的网站所有图片都是放在腾讯的cos（对象存储服务）上的，图片提供CDN加速，网站也用了百度和腾讯云的CDN（内容分发网络），所以在网页加载速度上还是比较好滴。<br>&nbsp;</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://timhbw.github.io/2016/03/22/33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Timhbw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tim博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/22/33/" itemprop="url">
                  就在今天，Swift 2.2 发布了！（iphone SE等也是）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-22T13:12:57Z">
                2016-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index">
                    <span itemprop="name">swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天北京时间凌晨1点，iphone的春季发布会召开，可惜太晚，我熬不住，早上一起来必定是iphone占据头条，然后一大波人说：哎呀，这性价比，这屏幕怎么这么小，怎么长的和iphone5s一个样子，一点创新都没有等等，或者国产手机大厂商会发微博说苹果眼光不行，现在消费者都接受5寸屏幕手机，你推出个4寸小屏手机，没乔布斯苹果的设计太烂等等。</p>
<p>早上一起来，打开挨踢之家，中关村在线，看一波头条。iphone SE有银色，金色，深空灰色，<em>玫瑰金</em>（不买玫瑰金你怎么知道我买的是最新款iphone SE，手动斜眼）。有16GB，64GB2个容量，处理器用的iphone6S上的64位A9，叼炸天，1200万摄像头，支持NFC，4K视频拍摄，价格方面：16GB RMB3288,64GB RMB4088.当然海外版性价比更高，64GB也就3000多。A9处理器带个4寸小身板，1136 x 640 像素分辨率的手机，这流畅度简直要飞起。</p>
<p>进入正题</p>
<p>先给大家一些swift学习地址，（swift于2015年12月4日正式开源）大家可以到这里学习：</p>
<ul>
<li><a href="https://swift.org/" target="_blank" rel="external">swift官网</a></li>
<li>The <a href="https://github.com/apple/swift" target="_blank" rel="external">Apple home on GitHub</a> hosts all the Swift source code</li>
<li>The <a href="https://swift.org/community/#code-of-conduct" target="_blank" rel="external">Swift mailing lists</a> are how we interact</li>
<li>The <a href="https://swift.org/getting-started/" target="_blank" rel="external">Getting Started</a> pages will help you setup a Swift development environment</li>
<li>The <a href="https://swift.org/download/" target="_blank" rel="external">Download</a> page includes pre-built binaries for the supported platforms</li>
<li>The <a href="https://swift.org/contributing/#contributing-code" target="_blank" rel="external">Swift Evolution Process</a> describes how new features are proposed<br>swift中文文档，官网翻译推荐文档，原话：<blockquote>
<p>A great example of this is the GitHub project for the Chinese translation:<br>github上可以下载阅读，地址：<a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" target="_blank" rel="external">中文版 Apple 官方 Swift 教程《The Swift Programming Language》</a></p>
</blockquote>
</li>
</ul>
<p>如果大家愿意的话，可以一起帮助翻译，人多力量大，让大家更好地学习，顺便提高自己，造福他人，地址：<a href="https://lists.swift.org/mailman/listinfo/swift-dev" target="_blank" rel="external">swift-dev</a></p>
<p>官网中有swift的详细介绍，不过都是英文滴，好在我英文还行，下面是swift2.2的<a href="https://swift.org/blog/swift-2-2-released/" target="_blank" rel="external">更新日志</a>：</p>
<p>Swift 2.2 is a minor language release that is mostly source-compatible with Swift 2.1. It contains the following language changes that went through the Swift’s evolution process:</p>
<ul>
<li>SE-0001: Allow (most) keywords as argument labels</li>
<li>SE-0015: Tuple comparison operators</li>
<li>SE-0014: Constraining AnySequence.init</li>
<li>SE-0011: Replace typealias keyword with associatedtype for associated type declarations</li>
<li>SE-0021: Naming Functions with Argument Labels</li>
<li>SE-0022: Referencing the Objective-C selector of a method</li>
<li>SE-0020: Swift Language Version Build Configuration<br>Beyond these language changes Swift 2.2 also contains numerous bug fixes, enhancements to diagnostics, and produces even faster-running code.</li>
</ul>
<p>&nbsp;</p>
<p>最后，其他的也就不墨迹，大家刚把得，加油，程序猿之路贵在学习，更新知识！</p>
<p>&nbsp;</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://timhbw.github.io/2016/03/16/32/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Timhbw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tim博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/16/32/" itemprop="url">
                  画流程图，UML图神器：亿图图示专家
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-16T14:45:34Z">
                2016-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/资源/" itemprop="url" rel="index">
                    <span itemprop="name">资源</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学生党文档比较多，一到学期末，各种实训报告，论文等等，里面经常要画流程图，UML图，以前用office，wps里面的画图工具，虽然能画出来，但是比例，风格总不是那么好，歪歪扭扭的，所以网上找工具，于是得到这么一个神器。功能比较多，画流程图，UML图不在话下。</p>
<p>简单介绍：</p>
<p>EDraw Max是一款功能强大的专业制作各种应用图形的设计软件，通过这款软件你可以轻松制作出流程图，组织结构图，业务流程，UML图，工作流程，程序结构，网络图，图表和图形，心智图，定向地<br>图以及数据库图表，该款软件内置了2000多个符号及预画库，让你在制作各类图形中应用自如，而且EDraw Max(亿图图示专家)是基于矢量绘图，这样制作的图形点用空间相对更少，对电脑的要求也非常的低，让我们完全没必要通过CorelDRAW、Photoshop之类的大型软件来制作各类专用图形。</p>
<p>适用范围：</p>
<p>流程设计、工作汇报、说明简介、程序设计、思路展示、网络布线等，都少不了要用流程图来形象清晰的说明问题。用Word自带的图形绘制工具，难免有点不够专业，功能也不是很完善，使用亿图专业流程图、网络图制作工具，不仅可以完成普通流程图的制作，还可以完成专业网络图的绘制，它界面美观，操作简单，自带的丰富素材库能帮你快速的绘制出满意的效果，还提供了丰富的模板和示例供参考。</p>
<p>下面是一些运行截图：<br><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/UMLindex.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/UMLindex.png" alt=""></a><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/UML1.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/UML1.png" alt=""></a><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/UML2.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/UML2.png" alt=""></a></p>
<p>这是我当时做文档的一张截图，画得不好，请见谅：</p>
<p><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/UML3.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/UML3.png" alt=""></a><br>下载链接：<br>[file]</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://timhbw.github.io/2016/03/16/31/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Timhbw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tim博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/16/31/" itemprop="url">
                  genymotion安卓模拟器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-16T13:54:59Z">
                2016-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>安卓开发的同学们用过安卓模拟器（当然我只是因为上课需要研究了下），Eclipse里面自带模拟器，但是用过的人都知道，非常难用，又慢又卡，genymotion是首选，国内外都非常推崇的，使用它你必须的注册一个账号，不然即使你安装了，也不能下载里面的机器。<br><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotionindex.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotionindex.png" alt=""></a></p>
<p>在我这里，貌似<a href="http://www.genymobile.com/" target="_blank" rel="external">genymotion</a>官网也被墙啦，记得前几年英文官网还能上去，不知道是不是校园网的问题。</p>
<p><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotionerror.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotionerror.png" alt=""></a></p>
<p>所以在这里给出基于2016/3/16的最新版genymotion-2.6.0-vbox的下载地址:</p>
<p>[file]</p>
<p>安装一直下一步就可以，免费软件，只不过要登录才能用。</p>
<p>安装完桌面会出现3个图标：<br><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotion1.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotion1.png" alt=""></a></p>
<p>点击Genymotion就可以愉快地运行了！<br><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotion2.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotion2.png" alt=""></a><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotion3.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotion3.png" alt=""></a><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotion4.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotion4.png" alt=""></a><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotion5.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotion5.png" alt=""></a><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotion6.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/genymotion6.png" alt=""></a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://timhbw.github.io/2016/03/13/29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Timhbw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tim博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/13/29/" itemprop="url">
                  国外代理账号说明
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-13T09:48:30Z">
                2016-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/国外代理/" itemprop="url" rel="index">
                    <span itemprop="name">国外代理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&nbsp;</p>
<h3 id="此页面内容失效！！！国际代理帐号密码说明请移步老司机开车"><a href="#此页面内容失效！！！国际代理帐号密码说明请移步老司机开车" class="headerlink" title="此页面内容失效！！！国际代理帐号密码说明请移步老司机开车"></a>此页面内容失效！！！国际代理帐号密码说明请移步<a href="http://vpn.huangbowei.com" target="_blank" rel="external">老司机开车</a></h3><p>&nbsp;</p>
<p>免责声明：本站提供的账号均为个人使用，请勿用作非法活动，使用者需负起一切使用后果。</p>
<p>vpn:</p>
<p>服务器名称（地址）：</p>
<p>vpn类型：pptp</p>
<p>用户名：</p>
<p>密码：</p>
<p>&nbsp;</p>
<p>ss:</p>
<p>地址：</p>
<p>端口：9008</p>
<p>密码：</p>
<p>加密：</p>
<p>&nbsp;</p>
<p>用的人多了，服务器偶尔会来大姨妈，表现为连不上服务器，或者连上了也非常慢，断断续续的样子。出现这种情况的时候，请联系我，会做下相应的处理，就会恢复得快一点。</p>
<p>如果你连不上服务器，请再三手动输入确认上面四项没有填错，依然连不上的话，请尝试PING下服务器看是否通，如果不通，一般是你的线路（电信、联通、地域、时间等相关，有可能是暂时性问题）问题。但注意在少数情况下不管你是否能PING通，都跟是否能连上ss服务器无关。最后说下一般都不会是服务器的问题，也就是说最大的可能性是：1.客户端，2.线路。</p>
<p>服务器域名会通过DNS解释成IP地址，域名对应的IP偶尔会变，也偶尔会用DNS做负载均衡，一个域名会解释到多个IP，如果使用时遇到问题，不妨试下改一改你客户端的DNS，一般避免用运营商的，可以用百度，阿里，谷歌，114等(180.76.76.76,223.5.5.5, 8.8.8.8, 114.114.114.114)。</p>
<p>一般客户端会有两种使用模式：1.自动/PAC，2.全局。在电脑客户端上一般默认是模式1，在这个模式下，会有一个PAC列表，里面是一些你平时访问不了的网站地址，例如twitt<em>*.com，goo</em>le.com，当你要访问的网站地址匹配到这个列表其中一个地址时，流量就会自动走ss路线，当访问的网站地址没匹配到时，例如baidu.com，qq.com默认是不在列表中的，这时流量就不会走ss路线。模式1应该是最好用的，但当然那个列表也不是万能的，总会漏掉一些平时访问不了的小众的网站，这时你可以切换模式2，全局模式，在这个模式下，访问所有网站都会走ss路线。假如你不想用全局模式，又想访问那些小众的网站，那你可以动手编辑那个PAC列表，把你想访问的网站加入去，至于编辑方法可以自己去搜索一下。</p>
<p>本站及本站所提供的ss服务(美国洛杉矶节点)运行在<a href="https://bandwagonhost.com/index.php" target="_blank" rel="external">搬瓦工VPS</a>上，点击<a href="https://bandwagonhost.com/aff.php?aff=6856" target="_blank" rel="external">链接</a> (自动使用我的优惠码)注册购买VPS可享受88折优惠。选洛杉矶或日本（不过新账号不能购买日本服务器）的机房在国内访问会比较快。(提示：搬瓦工可以使用支付宝或者PayPal支付，而PayPal可以使用银联卡，也即是一般的银行卡/借记卡来支付)</p>
<p>ss mac，windows，android客户端下载：</p>
<p>[file]</p>
<p>&nbsp;</p>
<p>使用教程见: <a href="http://www.huangbowei.com/archives/9.html" target="_blank" rel="external">科学上网利器 Shadowsocks 简介</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://timhbw.github.io/2016/03/12/28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Timhbw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tim博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/28/" itemprop="url">
                  小白搭建博客教程之流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-12T09:03:07Z">
                2016-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/建站/" itemprop="url" rel="index">
                    <span itemprop="name">建站</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>搭建个人博客其实说简单也简单，说难也难，当初我一个独自探索，到现在也差不多摸清门路了，因此写一个教程防止大家走弯路，少碰壁，以最迅速，最直接的方式完成它,一下全部为个人见解，如有误，请指出。下面是后续文章链接:</p>
<ol>
<li><a href="http://www.huangbowei.com/archives/76.html" target="_blank" rel="external">购买域名</a>；</li>
<li><a href="http://www.huangbowei.com/archives/77.html" target="_blank" rel="external">购买虚拟主机并搭建（Linux）</a>；</li>
<li><a href="http://www.huangbowei.com/archives/78.html" target="_blank" rel="external">域名解析</a>；</li>
<li><p><a href="http://www.huangbowei.com/archives/79.html" target="_blank" rel="external">wordpress等博客平台安装步骤</a>。<br>先说下大致步骤：</p>
</li>
<li><p>购买域名（如果你只打算以例如ip：115.159.xxx.xxx方式访问这步可以忽略），推荐<a href="https://sg.godaddy.com/zh/" target="_blank" rel="external">狗爹</a>（godaddy），有许多优惠，还安全，不用担心被封，国内购买域名的地方也有很多：<a href="https://www.dnspod.cn/" target="_blank" rel="external">Dnspod</a>，<a href="http://www.xinnet.com/" target="_blank" rel="external">新网</a>等等，但是出于国内众多因素，在国内购买域名不怕一万，就怕万一，哪天谁不开心啦，直接封你域名，当然，一般是不会的。</p>
</li>
<li>购买虚拟主机，如果你家有公网ip地址可以直接在家搭建，但是当前公网ip本来就少，会分配公网ip给个人的运营商几乎没有，电信的用户可以试试，貌似联系客户，强烈要求分配公网ip就可以。（如果你是在校大学生，强烈建议<a href="http://www.qcloud.com/" target="_blank" rel="external">腾讯云</a>，1元主机加免费.cn域名一直到赠送到你毕业为止，阿里的貌似对学生优惠只有3个月）</li>
<li><p>物色一个好的解析商，如<a href="https://www.dnspod.cn/" target="_blank" rel="external">DnsPod</a>，<a href="https://www.cloudxns.net/" target="_blank" rel="external">CloudXNS</a>等，我之前用的是DnsPod，然后转战CloudXNS(推荐)。</p>
<blockquote>
<ul>
<li>解析商大致的作用流程：用户访问www.huangbowei.com，然后解析商就会应用你在解析商那里填写的规则，把www.huangbowei.com解析到115.159.xxx.xxx,然后用户就可以访问你的博客内容。<ul>
<li>如果你直接访问ip地址，大致流程就是：用户输入115.159.xxx.xxx，转到访问博客内容。</li>
<li>如果你没有解析商，用户输入www.huangbowei.com，然后不知道转到哪一个虚拟主机，就不能访问。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>选择一个搭建博客的平台：<a href="https://cn.wordpress.org/" target="_blank" rel="external">wordpress</a>，<a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>，<a href="http://typecho.org/" target="_blank" rel="external">Typecho</a>，<a href="http://www.ghostchina.com/" target="_blank" rel="external">Ghost</a>，<a href="http://jekyll.bootcss.com/" target="_blank" rel="external">jekyll</a>等等，我第一个用的（也是大部分人第一次用的）就是wordpress，它操作简单，后台有图形化操作界面，主题多，插件多，使用人数多，碰到问题解决方法也多，但是现在越发臃肿，不能满足我对博客速度的极致要求，便转到Typecho，以后准备试试更简单，搭建环境更加简单，更黑客的Hexo。</p>
</li>
</ol>
<p>## </p>
<p>到这里，搭建博客大致的流程就结束啦，这只是一个大致的思路，由于全部写完篇幅过多，我准备过几天把每一步详细写出来，以及我碰到的问题，以及解答方法 。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://timhbw.github.io/2016/03/12/24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Timhbw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tim博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/24/" itemprop="url">
                  分享下平时我在windows平台下开发用的一些比较好的软件-winscp（四）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-11T16:47:13Z">
                2016-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/资源/" itemprop="url" rel="index">
                    <span itemprop="name">资源</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="WinSCP"><a href="#WinSCP" class="headerlink" title="WinSCP"></a>WinSCP</h3><p>WinSCP是一个Windows环境下使用SSH的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能就是在本地与远程计算机间安全的复制文件。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>图形用户界面</li>
<li>多语言</li>
<li>与Windows完美集成(拖拽, URL,快捷方式)</li>
<li>支持所有常用文件操作</li>
<li>支持基于SSH-1、SSH-2的SFTP和SCP协议</li>
<li>支持批处理脚本和命令行方式</li>
<li>多种半自动、自动的目录同步方式</li>
<li>内置文本编辑器</li>
<li>支持SSH密码、键盘交互、公钥和Kerberos(GSS) 验证</li>
<li>通过与Pageant(PuTTY Agent)集成支持各种类型公钥验证</li>
<li>提供Windows Explorer与Norton Commander界面</li>
<li>可选地存储会话信息</li>
<li>可将设置存在配置文件中而非注册表中，适合在移动介质上操作<br><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/winscp.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/winscp.png" alt=""></a></li>
</ul>
<p>WinSCP下载地址：</p>
<p>[file]</p>
<p>&nbsp;</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://timhbw.github.io/2016/03/12/23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Timhbw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tim博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/23/" itemprop="url">
                  分享下平时我在windows平台下开发用的一些比较好的软件-putty（三）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-11T16:35:45Z">
                2016-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/资源/" itemprop="url" rel="index">
                    <span itemprop="name">资源</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="putty"><a href="#putty" class="headerlink" title="putty"></a>putty</h4><blockquote>
<p>PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。较早的版本仅支持Windows平台，在最近的版本中开始支持各类Unix平台，并打算移植至Mac OS X上。除了官方版本外，有许多第三方的团体或个人将PuTTY移植到其他平台上，像是以Symbian为基础的移动电话。PuTTY为一开放源代码软件，主要由Simon Tatham维护，使用MIT licence授权。随着Linux在服务器端应用的普及，Linux系统管理越来越依赖于远程。在各种远程登录工具中，Putty是出色的工具之一。Putty是一个免费的、Windows 32平台下的telnet、rlogin和ssh客户端，但是功能丝毫不逊色于商业的telnet类工具。</p>
</blockquote>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1. 完全免费；</p>
<p>2. 对于HTML网页编程代码，可直接选择在不同的浏览器中打开查看，以方便进行调试；</p>
<p>3. 全面支持ssh1和ssh2；</p>
<p>4. 体积很小，仅472KB(0.62 版本)；</p>
<p>5. 操作简单，所有的操作都在一个控制面板中实现；</p>
<p><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/putty.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/putty.png" alt=""></a></p>
<p>[file]</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://timhbw.github.io/2016/03/11/27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Timhbw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tim博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/11/27/" itemprop="url">
                  MarkdownPad 在win10下html渲染错误This view has crashed
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-10T23:28:16Z">
                2016-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT技术/" itemprop="url" rel="index">
                    <span itemprop="name">IT技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前几天在安装MarkdownPad 的时候碰见一个问题，一直报错，不能正常运行，这里给出解决方法：<br><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/markdown%20error.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/markdown%20error.png" alt=""></a></p>
<p>windows 10系统 需要下载 一个  awesomium_v1.6.6_sdk_win 这是一个 HTML UI ENGINE</p>
<p>awesomium下载地址：</p>
<p>[file]</p>
<p>如果以上安装后问题还没解决，官方文档建议下载安装 Microsoft’s DirectX End-User Runtimes (June 2010).</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://timhbw.github.io/2016/03/11/20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Timhbw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tim博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/11/20/" itemprop="url">
                  面试中被面试官问到的问题答案(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-10T16:30:52Z">
                2016-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ios/" itemprop="url" rel="index">
                    <span itemprop="name">ios</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下问题的答案是之前写的一篇文章 <a href="http://www.shavekevin.com/mianshiwenti/" target="_blank" rel="external">面试中被面试官问到的问题</a> 现在把问题的答案整理了一份出来给大家。希望对大家有所帮助。如果整理的答案有问题，请联系我。shavekevin@gmail.com</p>
<p>1.请你谈谈static和宏定义的区别。什么时候用static什么时候用宏定义。<br>让你声明的常量只在你声明的文件里有作用要不编译器会保存</p>
<p>宏定义：</p>
<p>1）. 一般来说我们使用宏定义最常见的是定义一些常量 简单的”函数”（比如求两个数的最大小值）<br>例如：定义常量PI</p>
<pre><code>&lt;span class=&quot;hljs-preprocessor&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; PI 3.1415926&lt;/span&gt;
`&lt;/pre&gt;
定义函数
&lt;pre&gt;`&lt;span class=&quot;hljs-preprocessor&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; MIN(A,B) ((A) &amp;lt; (B) ? (A):(B))&lt;/span&gt;
`&lt;/pre&gt;
我们不对宏定义进行修改

2) . 使用宏定义可以在很大程度上可以简化我们的代码
例如：我们在写单例的时候 之前我们写的是
&lt;pre&gt;`&lt;span class=&quot;hljs-preprocessor&quot;&gt;#import &lt;span class=&quot;hljs-title&quot;&gt;&quot;ShareSingleton.h&quot;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ShareSingleton&lt;/span&gt;&lt;/span&gt;

+(instancetype)shareSingleton {

    &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; ShareSingleton *leader = &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;
    &lt;span class=&quot;hljs-built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^{
        leader = [[ShareSingleton alloc]init];
    });
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; leader;
}
&lt;span class=&quot;hljs-keyword&quot;&gt;@end&lt;/span&gt;
`&lt;/pre&gt;
//如果我们使用宏定义的话我们可以这样写：
&lt;pre&gt;`&lt;span class=&quot;hljs-preprocessor&quot;&gt;#define DISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, onceBlock);&lt;/span&gt;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;#import &lt;span class=&quot;hljs-title&quot;&gt;&quot;ShareSingleton.h&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ShareSingleton&lt;/span&gt;&lt;/span&gt;

+(instancetype)shareSingleton {

    &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; ShareSingleton *leader = &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;;
    DISPATCH_ONCE_BLOCK(^{
        leader = [[ShareSingleton alloc]init];
    })
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; leader;
}
&lt;span class=&quot;hljs-keyword&quot;&gt;@end&lt;/span&gt;
`&lt;/pre&gt;
其实#define的原理就是不管三七二十一，直接做替换，所以我们完全可以利用这个特点，发挥自己的想象，简化代码~ 宏定义实质是一个预编译指令，在程序未运行之前将某些指令付给相应的变量。

小结一下： static标记的变量会存储到全局变量区，生命周期和程序相同。而宏定义所定义的生命周期与所在的载体的生命周期有关.

static只在声明的类中可见。
在声明的类中结束后，再次使用还是之前的值。

2.你是怎么看待代理 通知的 他们有什么区别？
首先，我们把代理通知 放到一起来讨论第一反映是传值。 ok，下面慢慢来说各个的用法和区别。

通知中心

通过NSNotification可以给多个对象传递数据和消息(多个传递) 代理 通过protocol（代理模式）只能给一个对象传递数据和消息(单一传递)“一对一”，对同一个协议，一个对象只能设置一个代理delegate，所以单例对象就不能用代理（可以用多点回调，下面见解）。

代理更注重过程信息的传输：比如发起一个网络请求，可能想要知道此时请求是否已经开始、是否收到了数据、数据是否已经接受完成、数据接收失败。

区别： 代理和通知的区别应该主要是一对一和一对多的关系。delegate的多点回调相对notification更加便捷，更多方便，让项目更好维护。

3.说说你对内存管理的理解。

内存管理原则

引用计数的增加和减少相等，当引用计数降为0之后，不应该再使用这块内存空间。 凡是用alloc retain 或者copy让内存的引用计数增加了。就需要使用release或者autorelease让内存的引用 计数减少。在一段代码内。增加和减少的次数要相等。

autoreleasepool的使用

通过autoreleasepool控制autorelease对象的释放 向一个对象发送autorelease消息。这个对象何时释放取决于autoreleasepool

copy方法
跟retain不同，一个对象想要copy，生成自己的副本，需要实现NSCopying协议，定义copy的细节（如何copy）如果类没有接受NSCoping协议而给类发送copy消息，会引起crash 总结： OC借助引用计数机制去管理内存，凡是使用了alloc copy retain 等 方法，增加了引用计数，就要使用release 和autorelease 减少引用计数，引用计数为0的时候，对象所占的内存，被系统回收。

autorelease是未来某个时间（出autorelease）引用减一，不是即时的。

不是任何对象都可以接受copy消息。只有接受了NSCoping协议的对象才接受copy消息。

4.谈谈你对iOS性能优化的理解.

谈起iOS的性能优化我们首先想到的是应该是tableview表视图的优化。关于表视图的优化我们可以从以下几个方面来看:

1).tableviewcell渲染
绘制时要尽可能的避免分配资源，比如UIFont，NSDateFormatter或者任何在绘制时 需要的对象，推荐使用类层级的初始化方法中执行分配，并将其存储为静态变量。

2）.图层渲染的问题
透明图层对渲染性能会有一定的影响，系统必须将透明图层与下面的视图混合起来计算颜色，并 绘制出来。减少透明图层并使用不透明的图层来替代它们，可以极大地提高渲染速度。

3）.为代理方法瘦身
我们要尽量避免在tableview的cellforrowatindexpath的代理方法里写那么多代码，这样做不仅可以简化代码方便维护和管理，这对程序的运行也有帮助。

4).复杂视图尽量采用纯代码的方式

当 UITableViewCell拥有多个子视图时，IOS的渲染机制会拖慢速度。重写drawRect直接绘制内容的方式可 以提高性能，而不是在类初始化的时候初始化一些label或者imageview等。

（以下来源于yykit作者ibireme[这是源链接](http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)）

下面就是些CPU 资源消耗原因和解决方案 还有GPU资源消耗原因和解决方案

对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。

1).对象的创建
尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。

2).对象调整
对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。 当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。 3). 对象销毁
对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程 去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。 例如：
&lt;pre&gt;`&lt;span class=&quot;hljs-built_in&quot;&gt;NSArray&lt;/span&gt; *tmp = &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;.array&lt;/span&gt;;  
&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;.array&lt;/span&gt; = &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;;  
&lt;span class=&quot;hljs-built_in&quot;&gt;dispatch_async&lt;/span&gt;(queue, ^{  
    [tmp class];
});
`&lt;/pre&gt;
4).一些计算

视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。 不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些 属性。 Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：[http://pilky.me/36/。](http://pilky.me/36/%E3%80%82) 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架.

如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参 考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。

5).文本的绘制

如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。 屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染.

6).图片的解码

当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。

7).图像的绘制

图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）
&lt;pre&gt;`&lt;span class=&quot;hljs-built_in&quot;&gt;dispatch_async&lt;/span&gt;(backgroundQueue, ^{  
        CGContextRef ctx = CGBitmapContextCreate(...);
        &lt;span class=&quot;hljs-comment&quot;&gt;// draw in context...&lt;/span&gt;
        CGImageRef img = CGBitmapContextCreateImage(ctx);
        CFRelease(ctx);
        &lt;span class=&quot;hljs-built_in&quot;&gt;dispatch_async&lt;/span&gt;(mainQueue, ^{
            layer&lt;span class=&quot;hljs-variable&quot;&gt;.contents&lt;/span&gt; = img;
        });
    });
`&lt;/pre&gt;
GPU 资源消耗原因和解决方案

1.纹理的渲染

所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。 当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096，更详细的资料可以看这里：iosres.com。所以，尽量不要让图片和视图的大小超过这个值。

2.视图的混合
当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示

3.图像的生成

CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在 后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。
&lt;pre&gt;`如何检测应用的流畅度？
`&lt;/pre&gt;
“过早的优化是万恶之源”，在需求未定，性能问题不明显时，没必要尝试做优化，而要尽量正确的实现功能。做性能优化时，也最好是走修改代码 -&amp;gt; Profile -&amp;gt; 修改代码这样一个流程，优先解决最值得优化的地方。 如果你需要一个明确的 FPS 指示器，可以尝试一下 KMCGeigerCounter。对于 CPU 的卡顿，它可以通过内置的 CADisplayLink 检测出来；对于 GPU 带来的卡顿，它用了一个 1x1 的 SKView 来进行监视。这个项目有两个小问题：SKView 虽然能监视到 GPU 的卡顿，但引入 SKView 本身就会对 CPU/GPU 带来额外的一点的资源消耗；这个项目在 iOS 9 下有一些兼容问题，需要稍作调整。

5.你用过单元测试吗?怎么才能做好单元测试？
&gt; 什么是单元测试？
单元测试：以下内容来自维基百科[单元测试](https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95)

在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程 等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。
&lt;pre&gt;`通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到软件规格书要求的工作目标，没有程序错误；虽然单元测试不是什么必须的，但也不坏，这牵涉到项目管理的政策决定。

每个理想的测试案例独立于其它案例；为测试时隔离模块，经常使用&lt;span class=&quot;hljs-tag&quot;&gt;stubs&lt;/span&gt;、&lt;span class=&quot;hljs-tag&quot;&gt;mock&lt;/span&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[1]&lt;/span&gt;或&lt;span class=&quot;hljs-tag&quot;&gt;fake&lt;/span&gt;等测试马甲程序。单元测试通常由软件开发人员编写，用于确保他们所写的代码符合软件需求和遵循开发目标。它的实施方式可以是非常手动的（通过纸笔），或者是做成构建自动化的一部分。
`&lt;/pre&gt;
&gt; 单元测试有什么好处？
单元测试的一个好处就是我们可以只测试单个模块，我们可以测试 单一模块有没有问题。比如说我们在开发中经常会写一些测试性的demo。我们写的测试性demo运行正常达到了我们需要的效果，那么我们就可以把demo的效果运用到我们的工程中进行调试。
</code></pre><ul>
<li>适应变更单元测试允许程序员在未来重构代码，并且确保模块依然工作正确（复合测试）。这个过程就是为所有函数和方法编写单元测试，一旦变更导致错误发生，借助于单元测试可以快速定位并修复错误。可读性强的单元测试可以使程序员方便地检查代码片断是否依然正常工作。良好设计的单元测试案例覆盖程序单元分支和循环条件的所有路径。在连续的单元测试环境，通过其固有的持续维护工作，单元测试可以延续用于准确反映当任何变更发生时可执行程序和代码的表现。借助于上述开发实践和单元测试的覆盖，可以分分秒秒维持准确性。</li>
<li>简化集成单元测试消除程序单元的不可靠，采用自底向上的测试路径。通过先测试程序部件再测试部件组装，使集成测试变得更加简单。业界对于人工集成测试的必要性存在较大争议。尽管精心设计的单元测试体系看上去实现了集成测试，因为集成测试需要人为评估一些人为因素才能证实的方 面，单元测试替代集成测试不可信。一些人认为在足够的自动化测试系统的条件下，人力集成测试组不再是必需的。事实上，真实的需求最终取决于开发产品的特点 和使用目标。另外，人工或手动测试很大程度上依赖于组织的可用资源。[来源请求]</li>
<li><p>文档记录单元测试提供了系统的一种文档记录。借助于查看单元测试提供的功能和单元测试中如何使用程序单元，开发人员可以直观的理解程序单元的基础API。单元测试具体表现了程序单元成功的关键特点。这些特点可以指出正确使用和非正确使用程序单元，也能指出需要捕获的程序单元的负面表现（译注：异常和错误）。尽管很多软件开发环境不仅依赖于代码做为产品文档，在单元测试中和单元测试本身确实文档化了程序单元的上述关键特点。<br>另一方面，传统文档易受程序本身实现的影响，并且时效性难以保证（如设计变更、功能扩展等在不太严格时经常不能保持文档同步更新）。</p>
</li>
<li><p>表达设计在测试驱动开发的软件实践中，单元测试可以取代正式的设计。每一个单元测试案例均可以视为一项类、方法和待观察行为等设计元素。下面的Java例可以帮助说明这一点。 当然，单元测试缺乏图的可读性，但UML图可以在自由工具（通常可从IDE扩展获取）中为大多数现代程序语言生成UML图，很难要求采购昂贵的UML设计套装软件。自由工具，类似于基于xUnit框架的工具，测试结果输出到一些可生成供人工识读的图形化工具系统中去。</p>
</li>
<li>分离接口和实现因为很多类会引用其它类，对这个类的测试经常会要求测试其它的类。一个最普遍的例子是依赖于数据库的类：为了测试它，测试人员通常编写代码去操作数据库。这是不对的，因为单元测试不应超出待测试的类边界。作为替代，软件开发人员应创建一个数据库连接的抽象接口，然后实现这个接口的模拟对象。通过对代码所需附件的抽象（临时降低了网状的耦合效应），这些独立程序单元较前者更能被完整测试。高质量的代码单元也可提供更好的可维护性。</li>
<li><p>局限测试不可能发现所有的程序错误，单元测试也不例外。按定义，单元测试只测试程序单元自身的功能。因此，它不能发现集成错误、性能问题、或者其他系统 级别的问题。单元测试结合其他软件测试活动更为有效。与其它形式的软件测试类似，单元测试只能表明测到的问题，不能表明不存在未测试到的错误。软件测试是一个组合问题。例如，每一个布尔型的决断语句需要至少两种测试：一个返回真，一个返回假。因此，针对每行书写的代码，程序员通常需要写3 至5行的测试代码。[3]这很明显地很花时间而且对此的投入可能并不值得。也有些问题是根本不能简单地检测出来的——例如具不确定性的或牵扯到多线程的问 题。此外，替单元测试写的代码可能就像要测试的代码一样有程序错误。佛瑞德·布鲁克斯在人月神话一书中举例说明：“绝对不要带两个计时器去海边。最好总是 带一或三个”。意味着，如果两个计时器互相冲突的话，你该怎么知道哪个是对的？为了获得单元测试的好处，在软件开发过程中应形成一套严格纪律意识。仔细保 留记录是必要的，不仅仅只保留执行的测试，也包括保留对应的源码和其它软件单元的变更历史。即，使用版本控制系统是必要的。如果后续版本不能通过一个以前 测试通过的单元测试，版本控制系统可以提供对应时间段对源代码所做的变更清单。每天养成查看单元测试案例失败测试并及时确定错误原因的习惯是必要的。如果没有这样的流程，没有在团队工作流程中体现，单元测试系列将走向不同步，造成越来越多的错误和越来越低效的单元测试案例系列。</p>
<blockquote>
<p>iOS中的单元测试<br>在开发中，经常用到的单元测试一是测试某个模块的功能，也就是说把这个模块独立起来，单独进行测试。用到最多的应该是测试模块功能和接口调试功能。当然单元测试还有一些高级的用法自动测试和自动发布等。</p>
</blockquote>
<p>OCUnit（即用XCTest进行测试）其实就是苹果自带的测试框架，我们主要讲的就是这个。GHUnit是一个可视化的测试框架。（有了它，你可以点 击APP来决定测试哪个方法，并且可以点击查看测试结果等。）OCMock就是模拟某个方法或者属性的返回值，你可能会疑惑为什么要这样做?使用用模型生 成的模型对象，再传进去不就可以了？答案是可以的，但是有特殊的情况。比如你测试的是方法A，方法A里面调用到了方法B，而且方法B是有参数传入，但又不 是方法A所提供。这时候，你可以使用OCMock来模拟方法B返回的值。（在不影响测试的情况下，就可以这样去模拟。）除了这些，在没有网络的情况下，也 可以通过OCMock模拟返回的数据。UITests就是通过代码化来实现自动点击界面，输入文字等功能。靠人工操作的方式来覆盖所有测试用例是非常困难 的，尤其是加入新功能以后，旧的功能也要重新测试一遍，这导致了测试需要花非常多的时间来进行回归测试，这里产生了大量重复的工作，而这些重复的工作有些 是可以自动完成的，这时候UITests就可以帮助解决这个问题了。</p>
<p>6. 你知道的的本地数据持久化都有哪些。你比较喜欢用哪些 为什么？</p>
<p>采用的数据存储的方式有以下几种：<br>1、 FMDB（常用）<br>2、 Sqlite(次之)<br>3、 Coredata(次之)<br>4、 NSUserdefaults(最多使用)<br>5、 序列化反序列化（归档和解档）<br>6、 MongoDB(小众型的)</p>
<p>大家讨论用的最多的是FMDB，原因很简单，关系型数据库，使用方便(相对于没经过封装和加工的Sqlite来说)。其次就是sqlite和 coredata 当然使用者三种主要是为了缓存。因为我们在开发中为了给用户更好的体验，就采用缓存的形式。一般情况下要做的操作就是在本地建立一个数据库(本地后台)。</p>
<p>7.谈谈MVC设计模式的优缺点</p>
<p>编程以来就一直被灌输MVC设计模式，具体MVC使用到底好在哪里 又有那些不足之处，可以通过下面的介绍得以了解。</p>
<p>一、mvc原理</p>
<p>mvc是一种程序开发设计模式,它实现了显示模块与功能模块的分离。提高了程序的可维护性、可移植性、可扩展性与可重用性，降低了程序的开发难度。它主要分模型、视图、控制器三层。</p>
</li>
</ul>
<ol>
<li>模型(model)它是应用程序的主体部分，主要包括业务逻辑模块（web项目中的Action,dao类）和数据模块（pojo类）。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性</li>
<li>视图(view) 用户与之交互的界面、在web中视图一般由jsp,html组成</li>
<li><p>控制器(controller)接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的做用.<br>二、MVC的优点</p>
</li>
<li><p>可以为一个模型在运行时同时建立和使用多个视图。变化-传播机制可以确保所有相关的视图及时得到模型数据变化，从而使所有关联的视图和控制器做到行为同步。</p>
</li>
<li>视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换。</li>
<li>模型的可移植性。因为模型是独立于视图的，所以可以把一个模型独立地移植到新的平台工作。需要做的只是在新平台上对视图和控制器进行新的修改。</li>
<li><p>潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中。<br>三、MVC的不足之处</p>
</li>
<li><p>增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</p>
</li>
<li>视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li>
<li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li>
<li><p>目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成MVC使用的困难。<br>8.谈谈你对多线程的理解，你经常用的多线程有哪些实现方式，谈谈他们优缺点。</p>
<p>使用NSOperationQueue用来管理子类化的NSOperation对象，控制其线程并发数目。GCD和NSOperation都 可以实现对线程的管理，区别是 NSOperation和NSOperationQueue是多线程的面向对象抽象。项目中使用NSOperation的优点是NSOperation是 对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点（复用、封装），使得实现是 多线程支持，而接口简单，建议在复杂项目中使用。</p>
<p>项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。</p>
<blockquote>
<p>什么时候用多线程？<br>大多情况下,要用到多线程的主要是需要处理大量的IO操作时或处理的情况需要花大量的时间等等,比如:读写文 件、视频图像的采集、处理、显示、保存等。<br>多线程的作用?<br>可以解决负载均衡问题,充分利用cpu资源 。为了提高CPU的使用率,采用多线程的方式去同时完 成几件事情而互不干扰.<br>iOS实现多线程有哪几种方式？<br>主要有三种主要方法。</p>
</blockquote>
<p>1、NSThread。</p>
<p>2、NSOperation。</p>
<p>3、GCD。</p>
<blockquote>
<p>多线程安全问题的几种解决方案?<br>使用锁。锁是线程编程同步工具的基础。锁可以让你很容易保护代码中一大块区域以便你可以确保代码的正 确性。使用POSIX互斥锁;使用NSLock类;使用@synchronized指令等。<br>分线程回调主线程方法是什么？有什么作用呢？<br>回到主线程的方法:</p>
</blockquote>
<p>(1). performSelectorOnMainThrea<br><pre><code>[&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt; performSelectorOnMainThread:&amp;lt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#(SEL)#&amp;gt;withObject:&lt;span class=&quot;hljs-title&quot;&gt;&amp;lt;#(id)#&amp;gt;&lt;/span&gt;waitUntilDone:&lt;span class=&quot;hljs-title&quot;&gt;&amp;lt;#(BOOL)#&amp;gt;&lt;/span&gt;];&lt;/span&gt;</code></pre><br>(2). GCD<br><pre><code>&lt;span class=&quot;hljs-built_in&quot;&gt;dispatch_async&lt;/span&gt;(dispatch_get_main_queue(), ^{  
});</code></pre><br>(3). NSOperationQueue<br><pre><code>[[NSOperationQueue mainQueue]addOperationWithBlock:^{
}]</code></pre><br>作用:主线程是显示UI界面,子线程多数是进行数据处理.</p>
<p>PS:最高境界是异步单线程，江湖上称协程。<br>可以参考 boost 中的 asio 用户级的任务调度</p>
<p>9.谈谈你对面向对象和面向过程的认识。</p>
<p>简单对比</p>
<p>面向过程就像是一个细心的管家，事无具细的都要考虑到。而面向对象就像是个家用电器，你只需要知道他的功能，不需要知道它的工作原理。“面向过 程”是一种是事件为中心的编程思想。就是分析出解决问题所需的步骤，然后用函数把这写步骤实现，并按顺序调用。面向对象是以“对象”为中心的编程思想。</p>
<p>简单的举个例子：汽车发动、汽车到站</p>
<p>这对于“面向过程”来说，是两个事件，汽车启动是一个事件，汽车到站是另一个事件，面向过程编程的过程中我们关心的是事件，而不是汽车本身。针 对上述两个事件，形成两个函数，之后依次调用。然而这对于面向对象来说，我们关心的是汽车这类对象，两个事件只是这类对象所具有的行为。而且对于这两个行 为的顺序没有强制要求。</p>
<p>两种思想的对比</p>
<p>面向过程其实最为实际的一种思考方式，因为我们总是一贯一步一步的解决问题。(举个简单的事情，在初学面向对象的语言例如c++时，我们也总是 不经意的面向过程了!)。其实就算是面向对象思想也是包含有面向过程思想的，面向过程需形成事件、也就是函数，面向对象需抽象出类，并且也会定义出这类对 象的“行为”及方法。但是不论是面向过程的函数，还是面向对象的方法，两者所完成目的都是一致的。可以说面向过程是一种基础的方法，它考虑的是实际的实 现，一般情况下，面向过程是自顶向下逐步求精，其最重要的是模块化的思想方法。面向对象的方法主要是把事物给对象化，包括其属性和行为。这里在程序较小的 时候，面向过程就会体现出一种优势，其程序流程十分清楚。如同上述汽车发动、到站这一过程，面向过程可以很清晰的将这一过程体现出来。而面向对像仅仅是抽 象出一个Bus类，包括发动、到站之两个行为，具体的执行顺序不能体现出来。</p>
<p>面向过程和面向对象的本质理解</p>
<p>面向过程就是分析出解决问题所需的步骤，面向对象则是把构成问题的事物分解成对象，抽象出对象的目的并不在于完成某个步骤，而是描述其再整个解决问 题的步骤中的行为。面向过程的思维方式是分析综合，面向对象的思维方式是构造。 例如c语言解决问题时，一般是先定义数据结构，然后在构造算法。而是面向对象求解时则是先抽象出对象，构造一个“封闭”的环境，这个环境中有定义的数据和 解决问题的算法。面向过程的设计更具挑战性，技巧性，面向对象主要在于对象抽象的技术性，一旦完成抽象，任何人都可以做后面的工作了。从代码层结构上来说 的话，面向对象和面向过程的主要区别就是数据是单独存数还是与操作存储在一起。面向对象提供了数据的封装后，是的对某一操作而言，数据的访问变得可靠了。</p>
<p>面向过程就是将coding当做一件事，一步一步完成，面向对象就是将coding当做一件事物，需要做什么的时候由事物(对象)本身的行为去完成。</p>
<p>总的来说：</p>
</li>
</ol>
<ul>
<li>面向对象是将事物高度抽象化。</li>
<li>面向过程是一种自顶向下的编程。</li>
<li><p>面向对象必须先建立抽象模型，之后直接使用模型就行了。<br>面向过程就是说把做事情的步骤一步一步要干啥清楚明了的告诉我们。就是说我们知道具体是通过什么方式来实现的。</p>
<p>面向对象说白了就是我们只需要知道我们所使用的对象有什么功能，然后我们让对象去做事情。我们关心的不是实现的过程，而是能否实现和实现的结果。是事物抽象化的一种体现。</p>
<p>10.什么是单例？怎么用？有什么好处？指出你项目中用到的单例模式。</p>
<blockquote>
<p>什么是单例模式<br>单例模式的意思就是只有一个实例。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。</p>
</blockquote>
<p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>
<blockquote>
<p>单例模式的作用<br>可以保证在运行程序过程中，一个类只有一个实例，而且该实例易于供外界访问； 方便控制实例个数，节约系统资源。<br>如何使用？<br>单例是整个 Cocoa 中被广泛使用的核心设计模式之一。事实上，苹果开发者库把单例作为 “Cocoa 核心竞争力” 之一。作为一个iOS开发者，我们经常和单例打交道，比如 UIApplication 和 NSFileManager 等等。我们在开源项目、苹果示例代码和 StackOverflow 中见过了无数使用单例的例子。Xcode 甚至有一个默认的 “Dispatch Once” 代码片段，可以使我们非常简单地在代码中添加一个单例：<br><pre>`+ (instancetype)sharedInstance<br>{</pre></p>
<pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;dispatch_once_t&lt;/span&gt; once;
&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt; sharedInstance;
&lt;span class=&quot;hljs-built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;once, ^{
    sharedInstance = [[&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt; alloc] init];
});
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; sharedInstance;
</code></pre><p>}<br>`<br>由于这些原因，单例在 iOS 开发中随处可见。问题是，它们很容易被滥用。</p>
</blockquote>
<p>尽管有些人认为单例是 ‘反模式’， ‘魔鬼’ 以及 ‘病态的说谎者’，我不会去完全否认单例所带来的的好处，而是会展示一些使用单例所带来的问题，这样下一次在使用 dispatch_once 代码片段的自动补全功能时，你可以对它的影响进行评估，三思而行。</p>
<h3 id="全局状态"><a href="#全局状态" class="headerlink" title="全局状态"></a>全局状态</h3><p>大多数的开发者都认同使用全局可变的状态是不好的行为。太多状态使得程序难以理解，难以调试。我们这些面向对象的程序员在最小化代码的状态复杂程度的方面，有很多需要向函数式编程学习的地方。<br><pre>`<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SPMath</span> </span>{</pre></p>
<pre><code>NSUInteger _a;
NSUInteger _b;
</code></pre><p>}</p>
<ul>
<li>(NSUInteger)computeSum<br>{<br>  <span class="hljs-keyword">return</span> _a + _b;<br>}<br>`<br>在上面这个简单的数学库的实现中，程序员需要在调用 computeSum 前正确的设置实例变量 _a 和 _b。这样有以下问题：</li>
</ul>
<p>1.computeSum 没有显式地通过使用参数的形式声明它依赖于 _a 和 _b 的状态。与仅仅通过查看函数声明就可以知道这个函数的输出依赖于哪些变量不同的是，另一个开发者必须查看这个函数的具体实现才能明白这个函数依赖那些变量。隐藏依赖是不好的。</p>
<p>2.当为调用 computeSum 做准备而修改 _a 和 _b 的数值时，程序员需要保证这些修改不会影响任何其他依赖于这两个变量的代码的正确性。而这在多线程的环境中是尤其困难的。</p>
<p>把下面的代码和上面的例子做对比：<br><pre>`+ (NSUInteger)computeSumOf:(NSUInteger)a plus:(NSUInteger)b<br>{</pre></p>
<pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a + b;
</code></pre><p>}<br>`<br>这里，对变量 a 和 b 的依赖被显式地声明了。我们不需要为了调用这个方法而去改变实例变量的状态。并且我们也不需要担心调用这个函数会留下持久的副作用。我们甚至可以把这个方法声明为类方法，这样就告诉了代码的阅读者这个方法不会修改任何实例的状态。</p>
<p>那么，这个例子和单例又有什么关系呢？用 Miško Hevery 的话来说，”单例就是披着羊皮的全局状态”。一个单例可以被使用在任何地方，而不需要显式地声明依赖。就像变量 _a 和 _b 在 computeSum 内部被使用了，却没有被显式声明一样，程序的任意模块都可以调用 [SPMySingleton sharedInstance] 并且访问这个单例。这意味着任何和这个单例交互产生的副作用都会影响程序其他地方的任意代码。<br><pre>`<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SPSingleton</span> : <span class="hljs-title">NSObject</span></span></pre></p>
<ul>
<li>(instancetype)sharedInstance;</li>
</ul>
<ul>
<li>(NSUInteger)badMutableState;</li>
<li>(<span class="hljs-keyword">void</span>)setBadMutableState:(NSUInteger)badMutableState;</li>
</ul>
<p><span class="hljs-keyword">@end</span></p>
<p><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SPConsumerA</span></span></p>
<ul>
<li>(<span class="hljs-keyword">void</span>)someMethod<br>{<br>  <span class="hljs-keyword">if</span> ([[SPSingleton sharedInstance] badMutableState]) {<pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;
</code></pre>  }<br>}</li>
</ul>
<p><span class="hljs-keyword">@end</span></p>
<p><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SPConsumerB</span></span></p>
<ul>
<li>(<span class="hljs-keyword">void</span>)someOtherMethod<br>{<br>  [[SPSingleton sharedInstance] setBadMutableState:<span class="hljs-number">0</span>];<br>}</li>
</ul>
<p><span class="hljs-keyword">@end</span><br>`<br>在上面的例子中，SPConsumerA 和 SPConsumerB 是两个完全独立的模块。但是 SPConsumerB 可以通过使用单例提供的共享状态来影响 SPConsumerA 的行为。这种情况应该只能发生在 consumer B 显式引用了 A，并表明了两者之间的关系时。这里使用了单例，由于其具有全局和多状态的特性，导致隐式地在两个看起来完全不相关的模块之间建立了耦合。</p>
<p>让我们来看一个更具体的例子，并且暴露一个使用全局可变状态的额外问题。比如我们想要在我们的应用中构建一个网页查看器。为了支持这个查看器，我们构建了一个简单的 URL cache：<br><pre>`<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SPURLCache</span></span></pre></p>
<ul>
<li>(SPCache *)sharedURLCache;</li>
</ul>
<ul>
<li>(<span class="hljs-keyword">void</span>)storeCachedResponse:(NSCachedURLResponse <em>)cachedResponse forRequest:(<span class="hljs-built_in">NSURLRequest</span> </em>)request;</li>
</ul>
<p><span class="hljs-keyword">@end</span><br>`<br>这个开发者开始写一些单元测试来保证代码在一些不同的情况下都能达到预期。首先，他写了一个测试用例来保证网页查看器在设备没有连接时能够展示出错 误信息。然后他写了一个测试用例来保证网页查看器能够正确的处理服务器错误。最后，他为成功情况时写了一个测试用例，来保证返回的网络内容能够被正确的显 示出来。这个开发者运行了所有的测试用例，并且它们都如预期一样正确。赞！</p>
<p>几个月以后，这些测试用例开始出现失败，尽管网页查看器的代码从它写完后就从来没有再改动过！到底发生了什么？</p>
<p>原来，有人改变了测试的顺序。处理成功的那个测试用例首先被运行，然后再运行其他两个。处理错误的那两个测试用例现在竟然成功了，和预期不一样，因为 URL cache 这个单例把不同测试用例之间的 response 缓存起来了。</p>
<p>持久化状态是单元测试的敌人，因为单元测试在各个测试用例相互独立的情况下才有效。如果状态从一个测试用例传递到了另外一个，这样就和测试用例的执行顺序就有关系了。有 bug 的测试用例，尤其是那些本来不应该通过的测试用例，是非常糟糕的事情。</p>
<h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><p>另外一个关键问题就是单例的生命周期。当你在程序中添加一个单例时，很容易会认为 “永远只会有一个实例”。但是在很多我看到过的 iOS 代码中，这种假定都可能被打破。</p>
<p>比如，假设我们正在构建一个应用，在这个应用里用户可以看到他们的好友列表。他们的每个朋友都有一张个人信息的图片，并且我们想使我们的应用能够下 载并且在设备上缓存这些图片。 使用 dispatch_once 代码片段，我们可以写一个 SPThumbnailCache 单例：<br><pre>`<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SPThumbnailCache</span> : <span class="hljs-title">NSObject</span></span></pre></p>
<ul>
<li>(instancetype)sharedThumbnailCache;</li>
</ul>
<ul>
<li>(<span class="hljs-keyword">void</span>)cacheProfileImage:(<span class="hljs-built_in">NSData</span> <em>)imageData forUserId:(<span class="hljs-built_in">NSString</span> </em>)userId;</li>
<li>(<span class="hljs-built_in">NSData</span> <em>)cachedProfileImageForUserId:(<span class="hljs-built_in">NSString</span> </em>)userId;</li>
</ul>
<p><span class="hljs-keyword">@end</span><br>`<br>我们继续构建我们的应用，一切看起来都很正常，直到有一天，我们决定去实现‘注销’功能，这样用户可以在应用中进行账号切换。突然我们发现我们将要 面临一个讨厌的问题：用户相关的状态存储在全局单例中。当用户注销后，我们希望能够清理掉所有的硬盘上的持久化状态。否则，我们将会把这些被遗弃的数据残 留在用户的设备上，浪费宝贵的硬盘空间。对于用户登出又登录了一个新的账号这种情况，我们也想能够对这个新用户使用一个全新的 SPThumbnailCache 实例。</p>
<p>问题在于按照定义单例被认为是“创建一次，永久有效”的实例。你可以想到一些对于上述问题的解决方案。或许我们可以在用户登出时移除这个单例：<br><pre>`<span class="hljs-keyword">static</span> SPThumbnailCache *sharedThumbnailCache;</pre></p>
<ul>
<li><p>(instancetype)sharedThumbnailCache<br>{<br>  <span class="hljs-keyword">if</span> (!sharedThumbnailCache) {</p>
<pre><code>sharedThumbnailCache = [[&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt; alloc] init];
</code></pre><p>  }<br>  <span class="hljs-keyword">return</span> sharedThumbnailCache;<br>}</p>
</li>
<li><p>(<span class="hljs-keyword">void</span>)tearDown<br>{<br>  <span class="hljs-comment">// The SPThumbnailCache will clean up persistent states when deallocated</span><br>  sharedThumbnailCache = <span class="hljs-literal">nil</span>;<br>}<br>`<br>这是一个明显的对单例模式的滥用，但是它可以工作，对吧？</p>
</li>
</ul>
<p>我们当然可以使用这种方式去解决，但是代价实在是太大了。我们不能使用简单的的 dispatch_once 方案了，而这个方案能够保证线程安全以及所有调用 [SPThumbnailCache sharedThumbnailCache] 的地方都能访问到同一个实例。现在我们需要对使用缩略图 cache 的代码的执行顺序非常小心。假设当用户正在执行登出操作时，有一些后台任务正在执行把图片保存到缓存中的操作:<br><pre>`dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^{  </pre></p>
<pre><code>[[SPThumbnailCache sharedThumbnailCache] cacheProfileImage:newImage &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;UserId:userId];
</code></pre><p>});<br>`<br>我们需要保证在所有的后台任务完成前， tearDown 一定不能被执行。这确保了 newImage 数据可以被正确的清理掉。或者，我们需要保证在缩略图 cache 被移除时，后台缓存任务一定要被取消掉。否则，一个新的缩略图 cache 的实例将会被延迟创建，并且之前用户的数据 (newImage 对象) 会被存储在它里面。</p>
<p>由于对于单例实例来说它没有明确的所有者，(因为单例自己管理自己的生命周期)，“关闭”一个单例变得非常的困难。</p>
<p>分析到这里，我希望你能够意识到，“这个缩略图 cache 从来就不应该作为一个单例！”。问题在于一个对象得生命周期可能在项目的最初阶段没有被很好得考虑清楚。举一个具体的例子，Dropbox 的 iOS 客户端曾经只支持一个账号登录。它以这样的状态存在了数年，直到有一天我们希望能够同时支持多个用户账号登录 (同时登陆私人账号和工作账号)。突然之间，我们以前的的假设“只能够同时有一个用户处于登录状态”就不成立了。如果假定了一个对象的生命周期和应用的生 命周期一致，那你的代码的灵活扩展就受到了限制，早晚有一天当产品的需求产生变化时，你会为当初的这个假定付出代价的。</p>
<p>这里我们得到的教训是，单例应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该使用单例来管理。用一个单例来管理用户绑定的状态，是代码的坏味道，你应该认真的重新评估你的对象图的设计。</p>
<h4 id="避免使用单例"><a href="#避免使用单例" class="headerlink" title="避免使用单例"></a>避免使用单例</h4><p>既然单例对局部作用域的状态有这么多的坏处，那么我们应该怎样避免使用它们呢？</p>
<p>让我们来重温一下上面的例子。既然我们的缩略图 cache 的缓存状态是和具体的用户绑定的，那么让我们来定义一个user对象吧：<br><pre>`<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SPUser</span> : <span class="hljs-title">NSObject</span></span></pre></p>
<p><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) SPThumbnailCache *thumbnailCache;</p>
<p><span class="hljs-keyword">@end</span></p>
<p><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SPUser</span></span></p>
<ul>
<li><p>(instancetype)init<br>{<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init])) {</p>
<pre><code>_thumbnailCache = [[SPThumbnailCache alloc] init];

&lt;span class=&quot;hljs-comment&quot;&gt;// Initialize other user-specific state...&lt;/span&gt;
</code></pre><p>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>}</p>
</li>
</ul>
<p><span class="hljs-keyword">@end</span><br><code>&lt;/pre&gt;
我们现在用一个对象来作为一个经过认证的用户会话的模型类，并且我们可以把所有和用户相关的状态存储在这个对象中。现在假设我们有一个view controller来展现好友列表：
&lt;pre&gt;</code><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SPFriendListViewController</span> : <span class="hljs-title">UIViewController</span></span></p>
<ul>
<li>(instancetype)initWithUser:(SPUser *)user;</li>
</ul>
<p><span class="hljs-keyword">@end</span><br>`<br>我们可以显式地把经过认证的 user 对象作为参数传递给这个 view controller。这种把依赖性传递给依赖对象的技术正式的叫法是依赖注入，它有很多优点：</p>
<p>1.对于阅读这个 SPFriendListViewController 头文件的读者来说，可以很清楚的知道它只有在有登录用户的情况下才会被展示。</p>
<p>2.这个 SPFriendListViewController 只要还在使用中，就可以强引用 user 对象。举例来说，对于前面的例子，我们可以像下面这样在后台任务中保存一个图片到缩略图 cache 中：<br><pre>`dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^{  </pre></p>
<pre><code>[_user.thumbnailCache cacheProfileImage:newImage &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;UserId:userId];
</code></pre><p>});</p>
</li>
</ul>
<p>就算后台任务还没有完成，应用其他地方的代码也可以创建和使用一个全新的 SPUser 对象，而不会在清理第一个实例时阻塞用户交互. 为了更详细的说明一下第二点，让我们画一下在使用依赖注入之前和之后的对象图。</p>
<p>假设我们的 SPFriendListViewController 是当前 window 的 root view controller。使用单例时，我们的对象图看起来如下所示：</p>
<p><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/questions1.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/questions1.png" alt=""></a></p>
<p>view controller 自己，以及自定义的 image view 的列表，都会和 sharedThumbnailCache 产生交互。当用户登出后，我们想要清理 root view controller 并且退出到登录页面：</p>
<p><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/questions2.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/questions2.png" alt=""></a><br>这里的问题在于这个好友列表的 view controller 可能仍然在执行代码 (由于后台操作的原因)，并且可能因此仍然有一些没有执行的涉及到 sharedThumbnailCache 的调用。</p>
<p>和使用依赖注入的解决方案对比一下：</p>
<p><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/questions3.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/questions3.png" alt=""></a></p>
<p>简单起见，假设 SPApplicationDelegate 管理 SPUser 的实例 (在实践中，你可能会把这些用户状态的管理工作交给另外一个对象来做，这样可以使你的 application delegate 简化)。当展现好友列表 view controller 时，会传递进去一个 user 的引用。这个引用也会向下传递给 profile image views。现在，当用户登出时，我们的对象图如下所示：</p>
<p><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/questions4.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/questions4.png" alt=""></a></p>
<p>这个对象图看起来和使用单例时很像。那么，区别是什么呢？</p>
<p>关键问题是作用域。在单例那种情况中，sharedThumbnailCache 仍然可以被程序的任意模块访问。假如用户快速的登录了一个新的账号。该用户也想看看他的好友列表，这也就意味着需要再一次的和缩略图 cache 产生交互：</p>
<p><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/questions5.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/questions5.png" alt=""></a></p>
<p>当用户登录一个新账号，我们应该能够构建并且与全新的 SPThumbnailCache 交互，而不需要再在销毁老的缩略图 cache 上花费精力。基于对象管理的典型规则，老的 view controllers 和老的缩略图 cache 应该能够自己在后台延迟被清理掉。简而言之，我们应该隔离用户 A 相关联的状态和用户 B 相关联的状态：</p>
<p><a href="https://www.huangbowei.com/wp-content/uploads/2017/01/questions6.png" target="_blank" rel="external"><img src="https://www.huangbowei.com/wp-content/uploads/2017/01/questions6.png" alt=""></a></p>
<p>&nbsp;</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>这一切的关键点是，在面向对象编程中我们想要最小化可变状态的作用域。但是单例却因为使可变的状态可以被程序中的任何地方访问，而站在了对立面。下一次你想使用单例时，能够好好考虑一下使用依赖注入作为替代方案。</p>
<p>&nbsp;</p>
<p>原文：shavekevin.com/2016/02/28/mianshiwentidaanyi</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Timhbw" />
          <p class="site-author-name" itemprop="name">Timhbw</p>
           
              <p class="site-description motion-element" itemprop="description">自学iOS开发进阶博客，分享高质量的iOS开发技术。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">83</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">105</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Timhbw</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
